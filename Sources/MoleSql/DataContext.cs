/*
 * (C)2020 by René Vogt
 *
 * Published under MIT license as described in the LICENSE.md file.
 *
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using JetBrains.Annotations;
using MoleSql.Exceptions;

namespace MoleSql
{
    /// <summary>
    /// Represents a data context for the MoleSQL ORM framework.
    /// </summary>
    public class DataContext : IDisposable
    {
        readonly QueryProvider provider;

        bool disposed;

        /// <summary>
        /// Gets or sets a <see cref="TextWriter"/> that receives the SQL queries generated by the
        /// underlying query provider. Only the <see cref="TextWriter.WriteLine(string)"/> overload
        /// is used when writing to this <see cref="TextWriter"/>, and each "line" is a complete SQL
        /// statement. So when providing a custom implementation, only this overload needs to be
        /// overwritten to catch all log messages.
        /// </summary>
        public TextWriter Log
        {
            get => provider.Log;
            set => provider.Log = value;
        }
        /// <summary>
        /// Gets the underlying <see cref="SqlConnection"/> of this context.
        /// </summary>
        public SqlConnection Connection => provider.Connection;
        /// <summary>
        /// Gets or sets the transaction to use when interacting with the database.
        /// </summary>
        public SqlTransaction Transaction
        {
            get => provider.Transaction;
            set => provider.Transaction = value;
        }

        /// <summary>
        /// Creates a new <see cref="DataContext"/> for the specified connection.
        /// </summary>
        /// <param name="connectionString">A connection string defining the SQL server connection to use.</param>
        public DataContext(string connectionString) : this(new SqlConnection(connectionString), true)
        {
        }
        /// <summary>
        /// Creates a new <see cref="DataContext"/> for the given <see cref="SqlConnection"/>.
        /// </summary>
        /// <param name="connection">The <see cref="SqlConnection"/> to use with this context.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connection"/> was <code>null</code>.</exception>
        public DataContext([NotNull] SqlConnection connection) : this(connection, false)
        {
        }
        /// <summary>
        /// Creates a new <see cref="DataContext"/> for the given <see cref="SqlConnection"/>.
        /// </summary>
        /// <param name="connection">The <see cref="SqlConnection"/> to use with this context.</param>
        /// <param name="ownConnection"><code>true</code> if the <paramref name="connection"/> should be owned by this context
        /// and disposed when this context is disposed, <code>false</code> if the caller stays responsible for the connection.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connection"/> was <code>null</code>.</exception>
        public DataContext([NotNull] SqlConnection connection, bool ownConnection)
        {
            if (connection == null)
                throw new ArgumentNullException(nameof(connection));
            provider = new QueryProvider(connection, ownConnection);
        }
        /// <inheritdoc />
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        /// <summary>
        /// Disposes of this <see cref="DataContext"/> and the underlying connection if necessary.
        /// </summary>
        /// <param name="disposing"><code>true</code> if called by <see cref="Dispose()"/>, <code>false</code> if called from a finalizer.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposed || !disposing) return;
            provider.Dispose();
            disposed = true;
        }

        /// <summary>
        /// Creates a query to the specified table.
        /// </summary>
        /// <typeparam name="T">The table to query.</typeparam>
        /// <returns>An <see cref="IQueryable{T}"/> representing a query to the table specified by <typeparamref name="T"/>.</returns>
        public Query<T> GetTable<T>()
        {
            CheckDisposed();
            return new Query<T>(provider);
        }

        /// <summary>
        /// Starts a database transaction with the specified isolation level and transaction name.
        /// </summary>
        /// <returns>An object representing the new transaction.</returns>
        /// <exception cref="SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception>
        /// <exception cref="InvalidOperationException">Parallel transactions are not supported.</exception>
        public SqlTransaction BeginTransaction() => provider.BeginTransaction();
        /// <summary>
        /// Starts a database transaction with the specified isolation level and transaction name.
        /// </summary>
        /// <param name="transactionName">The name of the transaction.</param>
        /// <returns>An object representing the new transaction.</returns>
        /// <exception cref="SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception>
        /// <exception cref="InvalidOperationException">Parallel transactions are not supported.</exception>
        public SqlTransaction BeginTransaction(string transactionName) => provider.BeginTransaction(transactionName);
        /// <summary>
        /// Starts a database transaction with the specified isolation level and transaction name.
        /// </summary>
        /// <param name="iso">The isolation level under which the transaction should run.</param>
        /// <returns>An object representing the new transaction.</returns>
        /// <exception cref="SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception>
        /// <exception cref="InvalidOperationException">Parallel transactions are not supported.</exception>
        public SqlTransaction BeginTransaction(IsolationLevel iso) => provider.BeginTransaction(iso);
        /// <summary>
        /// Starts a database transaction with the specified isolation level and transaction name.
        /// </summary>
        /// <param name="iso">The isolation level under which the transaction should run.</param>
        /// <param name="transactionName">The name of the transaction.</param>
        /// <returns>An object representing the new transaction.</returns>
        /// <exception cref="SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception>
        /// <exception cref="InvalidOperationException">Parallel transactions are not supported.</exception>
        public SqlTransaction BeginTransaction(IsolationLevel iso, string transactionName) => provider.BeginTransaction(iso, transactionName);
        /// <summary>
        /// Executes the given query and returns a sequence of results.
        /// </summary>
        /// <typeparam name="T">The result type of the queried enumeration.</typeparam>
        /// <param name="query">The sql command to execute. Format parameters will be turned into query parameters.</param>
        /// <returns>An enumerator for the query results.</returns>
        public IEnumerable<T> ExecuteQuery<T>(FormattableString query) => provider.ExecuteQuery<T>(query);
        /// <summary>
        /// Executes the given query and returns an asynchronous sequence of results.
        /// </summary>
        /// <typeparam name="T">The result type of the queried enumeration.</typeparam>
        /// <param name="query">The sql command to execute. Format parameters will be turned into query parameters.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/> to cancel this asynchronous operation.</param>
        /// <returns>An asynchronous enumeration of the query results.</returns>
        public IAsyncEnumerable<T> ExecuteQueryAsync<T>(FormattableString query, CancellationToken cancellationToken = default) => provider.ExecuteQueryAsync<T>(query, cancellationToken);
        /// <summary>
        /// Executes the given query and returns a sequence of dynmic instances.
        /// If the result set contains only one column, these values are returned themselfes without wrapping
        /// them in a dynamic object.
        /// </summary>
        /// <param name="query">The sql command to execute. Format parameters will be turned into query parameters.</param>
        /// <returns>An enumerator for the query results. Those will be dynamic objects.</returns>
        public IEnumerable ExecuteQuery(FormattableString query) => provider.ExecuteQuery(query);
        /// <summary>
        /// Executes the given query and returns an asynchronous sequence of dynmic instances.
        /// If the result set contains only one column, these values are returned themselfes without wrapping
        /// them in a dynamic object.
        /// </summary>
        /// <param name="query">The sql command to execute. Format parameters will be turned into query parameters.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/> to cancel this asynchronous operation.</param>
        /// <returns>An asynchronous enumeratorion of the query results. Those will be dynamic objects.</returns>
        public IAsyncEnumerable<object> ExecuteQueryAsync(FormattableString query, CancellationToken cancellationToken = default) => provider.ExecuteQueryAsync(query, cancellationToken);
        /// <summary>
        /// Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.
        /// </summary>
        /// <param name="query">The query to execute.</param>
        /// <returns>The first column of the first row in the result set, or a null reference if the result set is empty. Returns a maximum of 2033 characters.</returns>
        public object ExecuteScalar(FormattableString query) => provider.ExecuteScalar(query);
        /// <summary>
        /// Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.
        /// </summary>
        /// <param name="query">The query to execute.</param>
        /// <typeparam name="T">The type to cast the result to.</typeparam>
        /// <returns>The first column of the first row in the result set as <typeparamref name="T"/>.</returns>
        public T ExecuteScalar<T>(FormattableString query) => provider.ExecuteScalar<T>(query);
        /// <summary>
        /// Executes the query asynchronously, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.
        /// </summary>
        /// <param name="query">The query to execute.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/> to cancel this asynchronous operation.</param>
        /// <returns>The first column of the first row in the result set, or a null reference if the result set is empty. Returns a maximum of 2033 characters.</returns>
        public Task<object> ExecuteScalarAsync(FormattableString query, CancellationToken cancellationToken = default) => provider.ExecuteScalarAsync(query, cancellationToken);
        /// <summary>
        /// Executes the query asynchronously, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.
        /// </summary>
        /// <param name="query">The query to execute.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/> to cancel this asynchronous operation.</param>
        /// <typeparam name="T">The type to cast the result to.</typeparam>
        /// <returns>The first column of the first row in the result set as <typeparamref name="T"/>.</returns>
        public Task<T> ExecuteScalarAsync<T>(FormattableString query, CancellationToken cancellationToken = default) => provider.ExecuteScalarAsync<T>(query, cancellationToken);
        /// <summary>
        /// Executes the given query or command and returns the number of affected rows.
        /// </summary>
        /// <param name="query">The sql command to execute. Format parameters will be turned into query parameters.</param>
        /// <returns>The number of affected rows.</returns>
        public Int32 ExecuteNonQuery(FormattableString query) => provider.ExecuteNonQuery(query);
        /// <summary>
        /// Executes the given query or command asynchronoulsy and returns a task that on completion returns the number of affected rows.
        /// </summary>
        /// <param name="query">The sql command to execute. Format parameters will be turned into query parameters.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/> to cancel this asynchronous operation.</param>
        /// <returns>The number of affected rows.</returns>
        public Task<Int32> ExecuteNonQueryAsync(FormattableString query, CancellationToken cancellationToken = default) => provider.ExecuteNonQueryAsync(query, cancellationToken);
        
        void CheckDisposed()
        {
            if (disposed) throw nameof(DataContext).ObjectDisposed();
        }
    }
}
